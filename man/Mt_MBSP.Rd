% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Mt_MBSP.R
\name{Mt_MBSP}
\alias{Mt_MBSP}
\title{Fits the Mt-MBSP model using the three parameter beta normal (TPBN) family.}
\usage{
  Mt_MBSP(X, Y, response_types, 
          u=0.5, a=0.5, tau=1/(dim(X)[2]*sqrt(dim(X)[1]*log(dim(X)[1]))), d1 = dim(Y)[2], d2=10, c1=10, c2=1,
          algorithm = c("1step","2step"),
          niter = 1100, burn=100, step2_niter = 1100, step2_burn=100, 
          threshold = seq(from=0.02, to=0.40, by=0.02),
          parallelize = TRUE, ncores = 10)
}
\arguments{
  \item{X}{n-by-p design matrix.}
  
  \item{Y}{n-by-q response matrix.}
  
  \item{response_types}{vector of q response types. The entries of the vector must be one of the following: "continuous", "binary", or "count".}
  
  \item{u}{first parameter in the TPBN family. Use (u,a)=(0.5,0.5) for the horseshoe prior.}
  
  \item{a}{second parameter in the TPBN family. Use (u,a)=(0.5,0.5) for the horseshoe prior.}
  
  \item{tau}{global shrinkage parameter. Must be between 0 and 1. Default is 1/p*sqrt(n*log(n)). If this quantity is below 1e-5, then tau is reset to 1e-5.}
  
  \item{d1}{degrees of freedom in inverse-Wishart prior on Sigma. Default is q (number of reponses).}
  
  \item{d2}{scale parameter in inverse-Wishart prior on Sigma. Default is 10.}
  
  \item{c1}{shape parameter in gamma prior on dispersion parameter r for count data. Default is 10. Ignored for non-count responses.}
  
  \item{c2}{rate parameter in gamma prior on dispersion parameter r for count data. Default is 1. Ignored for non-count responses.}
  
  \item{algorithm}{Two options are allowed: "1step" or "2step". The default is "1step", but "2step" may give better estimation and variable selection if p is large, especially if there are many weak signals.}
  
  \item{niter}{number of MCMC iterations to run for either the one-step algorithm OR Step 1 of the two-step algorithm. Default is 1100.}

  \item{burn}{number of MCMC samples to discard as burnin for either the one-step algorithm OR Step 1 of the two-step algorithm. Default is 100.}

  \item{step2_niter}{number of MCMC iterations to run in Step 2 of the two-step algorithm. This argument is only used if algorithm="2step". Default is 1100.}  

  \item{step2_burn}{number of MCMC samples to discard as burnin in Step 2 of the two-step algorithm. This argument is only used if algorithm="2step". Default is 100.}

  \item{threshold}{grid of gammas to tune the threshold gamma in Step 1 of the two-step algorithm using WAIC. This argument is only used if algorithm="2step". Default is a sequence 0.02, 0.04, ..., 0.40.}

  \item{parallelize}{Boolean variable for whether or not to run Step 2 of the two-step algorithm in parallel for the grid of values in threshold. Default is "TRUE". This argument is only used if algorithm="2step".} 
= 
  \item{ncores}{Number of cores to use for parallelization of Step 2 of the two-step algorithm. This argument is only used if algorithm="2step".}
}

\value{The function returns a list containing the following components:
\item{B_est}{posterior median estimate for p-by-q regression coefficients matrix B}
\item{B_active}{binary matrix with "1" for selected variable and "0" for inactive variable}
\item{B_lower}{0.025 quantile for posteriors of entries in B}
\item{B_upper}{0.975 quantile for posteriors of entries in B}
\item{Sigma_est}{posterior median estimate for Sigma}
\item{Sigma_lower}{0.025 quantile for posterior of Sigma}
\item{Sigma_upper}{0.975 quantile for posterior of Sigma}
\item{opt_threshold}{The optimal gamma chosen for the two-step algorithm. This is only returned if algorithm="2step"}
\item{B_samples}{MCMC samples of B saved after burnin. If algorithm="2step", then both Step 1 and Step 2 samples are returned}
\item{Sigma_samples}{MCMC samples of Sigma saved after burnin}
}

\description{
  This function takes an n-by-p design matrix X with n samples of p covariates
  and an n-by-q reponse matrix Y with n samples of q response variables which
  are allowed to be of mixed-type (i.e. continuous, binary, or count). Continuous
  responses are modeled as Gaussian, binary responses are modeled as Bernoulli,
  and count responses are modeled as negative binomial.
}
\examples{
###########################################
# EXAMPLE WITH 3 DIFFERENT RESPONSE TYPES #
###########################################
n <- 100  # sample size 
p <- 500  # number of covariates
s <- 5    # number of significant covariates
q <- 3    # number of multiple responses 
response_types <- c('binary','continuous','count')

# Set seed to reproduce results later
set.seed(123)

# Generate p-by-q regression coefficients matrix B0, where s=# of nonzero rows.
B0 <- generate_B0(p, s, response_types)
B0

# Generate true q-by-q covariance matrix Sigma0
Sigma0 <- generate_Sigma0(q)
# Generate nxp design matrix X
X <- generate_X(n, p)
# Generate nxq response matrix Y
Y <- generate_Y(X, B0, Sigma0, response_types)

# Y consists of continuous, binary, continuous, and binary responses in its columns
head(Y, n=10)

# Fit one-step model (default for Mt_MBSP function)

response_types <- c('binary','continuous','count')
output <- Mt_MBSP(X, Y, response_types)

# VERY IMPORTANT: Need to make sure that the response_types argument in Mt_MBSP is 
# correctly specified, otherwise the code may not run correctly!

# root mean squared error (rMSE) for one-step estimator
rMSE <- sqrt(sum((output$B_est-B0)^2)/(p*q))
rMSE

# Coverage probability (CP) for one-step estimator
coverage_mat <- matrix(0, nrow=p, ncol=q)

for(j in 1:p){
  for(k in 1:q){
    if(B0[j,k]>=output$B_lower[j,k] & B0[j,k]<=output$B_upper[j,k])
      coverage_mat[j,k] <- 1
  }
}
CP <- sum(coverage_mat)/(p*q)
CP 

# Variable selection performance for two-step estimator
classifications <- rep(0, p)
selected_variables <- which(rowSums(output$B_active)!=0)
classifications[selected_variables] <- 1

truth <- rep(0, p)
true_nonzero_variables <- which(rowSums(B0)!=0)
truth[true_nonzero_variables] <- 1

# Compare selected variables to the ground truth significant variables
selected_variables 
true_nonzero_variables

# FP, FN, TP, TN
FP <- length(which(classifications == 1 & truth == 0))
FN <- length(which(classifications == 0 & truth == 1))
TP <- length(which(classifications == 1 & truth == 1))
TN <- length(which(classifications == 0 & truth == 0))

sens <- TP/(TP+FN)
spec <- TN/(TN+FP)
MCC <- (TP*TN-FP*FN)/(sqrt((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN)))

sens
spec
MCC
}
